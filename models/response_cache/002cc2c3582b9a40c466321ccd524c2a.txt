Here's an example of TypeScript code that solves the ThreeSum problem on LeetCode:

```typescript
function threeSum(nums: number[]): number[][] {
  const result: number[][] = [];

  // Sort the array in ascending order
  nums.sort((a, b) => a - b);

  for (let i = 0; i < nums.length - 2; i++) {
    // Skip duplicate values for the first element
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }

    let left = i + 1;
    let right = nums.length - 1;

    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right];

      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]]);

        // Skip duplicate values for the second element
        while (left < right && nums[left] === nums[left + 1]) {
          left++;
        }

        // Skip duplicate values for the third element
        while (left < right && nums[right] === nums[right - 1]) {
          right--;
        }

        left++;
        right--;
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }

  return result;
}

// Example usage:
const nums = [-1, 0, 1, 2, -1, -4];
const result = threeSum(nums);
console.log(result); // Output: [[-1, -1, 2], [-1, 0, 1]]
```

In this code, we're using the two-pointer technique to find all unique triplets in the given array whose sum equals zero. We're iterating through the array using a loop and for each element, we're initializing left and right pointers to find the two other elements that sum to zero with the current element. We're updating the pointers based on the sum and skipping duplicate values to avoid duplicate triplets in the result.

The code has a time complexity of O(n^2), where n is the number of elements in the array.